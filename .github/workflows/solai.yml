name: solai-phase3-hello-world
on: [push]

defaults:
  run:
    shell: bash

env:
  DEBUG: "false"  # default debug flag for SWE-agent steps

jobs:
  lint-workflow:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check workflow files
        uses: docker://rhysd/actionlint:latest

  phase3_hello_world:
    needs: lint-workflow
    runs-on: ubuntu-latest
    env:
      # Define FOUNDRY_DIR at job level for use in cache and install steps
      FOUNDRY_DIR: /home/runner/.config/.foundry

    steps:
      # 1) Grab your code
      - uses: actions/checkout@v4

      # 2) Ensure Python 3.12
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      # Upgrade pip once at the beginning
      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      # Debug: Initial PATH state
      - name: Debug - Initial PATH
        run: |
          echo "Initial PATH: $PATH"
          echo "GITHUB_PATH content:"
          cat "$GITHUB_PATH" || echo "GITHUB_PATH not found"

      # 3) Install build tool + build your wheel
      - name: Install build tooling
        run: |
          python -m pip install build
      - name: Build wheel
        run: python -m build

      # 4) Install your wheel + AI backends via pip
      - name: Install solai wheel
        run: |
          wheel=$(ls dist/solai-*.whl)
          echo "Installing wheel: $wheel"
          # Don't install [ai] extras since we're installing SWE-agent directly
          python -m pip install --quiet "${wheel}"

      # 4a) Install Slither
      - name: Install Slither
        run: python -m pip install --quiet "slither-analyzer>=0.11.3"

      # -------------------------------------------------------------
      # 4b) Determine latest Foundry version (does NOT need Foundry)
      # -------------------------------------------------------------
      - name: Query Foundry version            # runs fast (~150 ms)
        id: foundry_version
        run: |
          version=$(curl -s https://api.github.com/repos/foundry-rs/foundry/releases/latest \
                   | jq -r .tag_name)
          echo "version=${version}" >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------
      # 4c) Restore Foundry from cache (if we already built it once)
      # -------------------------------------------------------------
      - name: Cache Foundry directory
        id: cache-foundry
        uses: actions/cache@v4
        with:
          path: ${{ env.FOUNDRY_DIR }}
          key: ${{ runner.os }}-foundry-${{ steps.foundry_version.outputs.version }}

      - name: Restore Foundry from cache
        if: steps.cache-foundry.outputs.cache-hit == 'true'
        run: |
          echo "${FOUNDRY_DIR}/bin" >> "$GITHUB_PATH"
          export PATH="${FOUNDRY_DIR}/bin:$PATH"
          forge --version

      # -------------------------------------------------------------
      # 4d) Install Foundry (ONLY if cache missed)
      # -------------------------------------------------------------
      - name: Install Foundry
        if: steps.cache-foundry.outputs.cache-hit != 'true'
        run: |
          # 1) Create Foundry directory
          mkdir -p "${FOUNDRY_DIR}/bin"
          # 2) Download foundryup directly into the standard dir
          curl -L https://raw.githubusercontent.com/foundry-rs/foundry/master/foundryup/foundryup \
               -o "${FOUNDRY_DIR}/bin/foundryup"
          # 3) Make executable
          chmod +x "${FOUNDRY_DIR}/bin/foundryup"
          # 4) Add to temp PATH
          export PATH="${FOUNDRY_DIR}/bin:$PATH"
          # 5) Install full suite
          foundryup || echo "foundryup command failed with exit code $?"
          # 6) Verify
          ls -la "${FOUNDRY_DIR}/bin/forge"
          # 7) Persist correct path
          echo "${FOUNDRY_DIR}/bin" >> "$GITHUB_PATH"
          # 8) Verify again
          export PATH="${FOUNDRY_DIR}/bin:$PATH"
          which forge
          forge --version

      # Debug: Post Docker PATH
      - name: Debug - Post Docker PATH
        run: |
          echo "PATH after Docker setup: $PATH"
          cat "$GITHUB_PATH"
          # skip redundant Foundry install if cache hit
          if [[ "${{ steps.cache-foundry.outputs.cache-hit }}" == 'true' ]]; then
            echo "Foundry cache hit ‚Äì skipping binary path export"
          else
            which forge || echo "forge not found in PATH"
          fi

      # 4e) Install SWE-Agent & SWE-ReX (GitHub tag v1.0.1)
      - name: Install SWE-Agent & SWE-ReX
        env:
          DEBUG: ${{ env.DEBUG }}    # set to "true" for debug dumps (prints paths)
        run: |
          python -m pip install --quiet --no-cache-dir \
            "git+https://github.com/swe-agent/swe-agent@v1.0.1" \
            "swe-rex==1.2.1" \
            "openai>=1.75.0,<2"

          # ------------------------------------------------------------------
          # Combined work-around: create config, tools & trajectories dirs; optional debug
          # ------------------------------------------------------------------
          python - <<'PY'
          import importlib.util, pathlib, sys, textwrap, site, os

          spec = importlib.util.find_spec("sweagent")
          if spec is None:
              sys.exit("‚ùå sweagent not found after install")

          pkg_dir = pathlib.Path(spec.origin).parent
          site_pkg = pathlib.Path(site.getsitepackages()[0])

          # Create config, tools, and trajectories directories
          for base in [pkg_dir, site_pkg]:
              for sub in ("config", "tools", "trajectories"):
                  d = base / sub
                  d.mkdir(parents=True, exist_ok=True)
                  if sub == "config":
                      cfg = d / "default.yaml"
                      if not cfg.exists():
                          cfg.write_text(textwrap.dedent("""\
          #############################
          # Minimal placeholder config
          #############################
          agent:
            name: placeholder
          """))

          # Optional debug output
          if os.getenv("DEBUG", "").lower() in ("1", "true"):
              print(f"sweagent pkg_dir: {pkg_dir}")
              print(f"site-packages base: {site_pkg}")
              for path in (
                  pkg_dir / "config",
                  site_pkg / "config",
                  pkg_dir.parent / "tools",
                  site_pkg / "tools",
                  pkg_dir.parent / "trajectories",
                  site_pkg / "trajectories",
              ):
                  print(f"- {path}: {'exists' if path.exists() else 'missing'}")
          PY

          which sweagent || { echo "sweagent CLI not in PATH"; exit 1; }

      # 5) Set up Docker
      - name: Set up QEMU emulation
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 6) Build Phase 3 Required Docker Image
      - name: Build Phase 3 Docker Image
        id: docker_build
        shell: bash
        run: |
          set -e
          ARCH="$(dpkg --print-architecture)"
          BASE_TAG="foundry_sol:0.4.6"
          ARCH_TAG="${BASE_TAG}-${ARCH}"

          printf '%s\n' '--- Building Phase 3 Docker image'
          printf '%s\n' "      ‚Ä¢ arch:        $ARCH"
          printf '%s\n' "      ‚Ä¢ base tag:    $BASE_TAG"
          printf '%s\n' "      ‚Ä¢ final tag:   $ARCH_TAG"
          printf '%s\n' "      ‚Ä¢ dockerfile:  src/solai/docker/foundry_sol.Dockerfile"

          docker build --platform "linux/${ARCH}" -t "${ARCH_TAG}" --progress=plain \
            -f src/solai/docker/foundry_sol.Dockerfile .

          printf '%s\n' '--- Docker image build finished ---'

          if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep -Fxq "${ARCH_TAG}"; then
            printf '%s\n' "‚ùå Failed to build or tag image $ARCH_TAG"
            exit 1
          fi

          printf '%s\n' "‚úì Image $ARCH_TAG built successfully."
          echo "image_tag=${ARCH_TAG}" >> "$GITHUB_OUTPUT"

      # 7) Run Phase 3 Hello-World Test
      - name: Phase 3 - SWE-Agent Run
        id: swe_agent_run_step
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          TARGET_IMAGE_TAG: ${{ steps.docker_build.outputs.image_tag }}
        shell: bash
        run: |
          set -e
          printf '%s\n' '--- 1Ô∏è‚É£ Creating isolated failing demo repo ---'
          cd /tmp && rm -rf demo && mkdir demo && cd demo
          git init -q

          cat > Greeter.sol << 'SOL'
          pragma solidity ^0.8.26;
          contract Greeter {
              string private greeting = "hello";
              function greet() external view returns (string memory) {
                  return greeting;
              }
          }
          SOL

          # align heredoc indentation
          cat > Greeter.t.sol << 'SOLTEST'
          pragma solidity ^0.8.26;
          import "forge-std/Test.sol";
          import "./Greeter.sol";

          contract GreeterTest is Test {
              Greeter g;
              function setUp() public { g = new Greeter(); }
              /// @notice Wrong on purpose
              function testGreetingFails() public {
                  assertEq(g.greet(), "HELLO");
              }
          }
          SOLTEST

          if forge test -q; then
            printf '%s\n' '‚ùå tests unexpectedly green'
            exit 1
          else
            printf '%s\n' '‚úì baseline red'
          fi

          if ! grep -q '"HELLO"' Greeter.t.sol; then
            printf '%s\n' '‚ùå HELLO literal missing'
            exit 1
          fi
          printf '%s\n' '‚úì Checkpoint 1 Passed'

          printf '%s\n' '--- 2Ô∏è‚É£ Authoring minimal swe.yaml ---'
          cp "${GITHUB_WORKSPACE}/.github/swe-agent-configs/phase3_hello_world.yaml" swe.yaml
          sed -i "s|DYNAMIC_IMAGE_TAG_PLACEHOLDER|${TARGET_IMAGE_TAG}|" swe.yaml
          printf '%s\n' "‚úì Updated swe.yaml to use image: $TARGET_IMAGE_TAG"

          printf '%s\n' '--- 2bÔ∏è‚É£ Validating swe.yaml syntax ---'
          # install PyYAML for YAML parsing
          python -m pip install --quiet pyyaml
          # parse swe.yaml to catch syntax errors
          python - << 'PY'
          import yaml, sys
          try:
              yaml.safe_load(open("swe.yaml"))
              print("‚úì swe.yaml valid YAML syntax")
          except Exception as e:
              print(f"‚ùå swe.yaml syntax error: {e}")
              sys.exit(1)
          PY

          printf '%s\n' '--- 3Ô∏è‚É£ Running SWE-Agent inside SWE-ReX ---'
          TS=$(date +%Y%m%dT%H%M%S)
          LOGFILE="run_${TS}.log"

          set +e
          sweagent run --config swe.yaml --output_dir . 2>&1 | tee "$LOGFILE"
          ret=$?
          set -e

          printf '%s\n' "--- ü©∫ Exit Code: $ret"

          printf '%s\n' '--- ü™µ Capturing container logs ---'
          CID=$(grep -oP 'Starting container \K[^ ]+' "$LOGFILE" | head -n1)
          if [ -n "$CID" ]; then
            docker logs "$CID" || true
          fi

          if [ "$ret" -ne 0 ] || [ ! -s patch.tar ]; then
            printf '%s\n' '‚ùå SWE-Agent run failed or patch missing'
            exit 1
          fi

          printf '%s\n' '‚úì Agent produced patch.tar'
          printf '%s\n' '--- 4Ô∏è‚É£ Applying patch... ---'
          tar -xf patch.tar
          mapfile -d $'\0' patch_files < <(find . -maxdepth 1 -name '*.[pd][ia][ft]' -print0)

          if [ "${#patch_files[@]}" -eq 0 ]; then
            printf '%s\n' '‚ùå No patch files'
            exit 1
          fi

          for p in "${patch_files[@]}"; do
            [ -z "$p" ] && continue
            printf '%s\n' "‚Üí validating $p"
            size=$(stat -c%s "$p")
            [ "$size" -lt 100000 ] || { printf '%s\n' "üí• $p too large"; exit 1; }

            git apply --stat "$p" > stat.txt
            loc_ins=$(grep -oP '(\d+)\s+insertions?' stat.txt | awk '{s+=$1} END{print s}')
            loc_del=$(grep -oP '(\d+)\s+deletions?' stat.txt | awk '{s+=$1} END{print s}')
            total=$((loc_ins+loc_del))
            [ "$total" -le 2000 ] || { printf '%s\n' "üí• patch $p changes $total LOC"; exit 1; }

            printf '%s\n' "Applying $p"
            git apply "$p" || { printf '%s\n' "‚ùå apply failed $p"; exit 1; }
          done

          if forge test -q; then
            printf '%s\n' '‚úì tests green after patch'
          else
            printf '%s\n' '‚ùå tests still failing'
            exit 1
          fi

          printf '%s\n' '--- 5Ô∏è‚É£ Bundling evidence ---'
          mkdir -p .evidence
          # Handle potential missing slither.txt gracefully
          [ -f stat.txt ] && mv stat.txt .evidence/
          [ -f slither.txt ] && mv slither.txt .evidence/
          mv patch.tar "$LOGFILE" .evidence/ 
          TB="phase3_evidence_${TS}.tgz"
          tar -czf "$TB" .evidence
          # Move bundle to /tmp for upload
          mv "$TB" /tmp/
          echo "bundle_name=$TB" >> "$GITHUB_OUTPUT"
          printf '%s\n' "‚úÖ Evidence: $TB"

      # 8) Upload Phase 3 Evidence Bundle
      - name: Upload Phase 3 Evidence
        uses: actions/upload-artifact@v4
        with:
          name: phase3-evidence
          # Correct path using the step output
          path: /tmp/${{ steps.swe_agent_run_step.outputs.bundle_name }}
          if-no-files-found: error 