name: solai-phase3-hello-world
on: [push]

jobs:
  phase3_hello_world:
    runs-on: ubuntu-latest

    steps:
      # 1) Grab your code
      - uses: actions/checkout@v4

      # 2) Ensure Python 3.12
      - name: Set up Python 3.12
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      # Debug: Initial PATH state
      - name: Debug - Initial PATH
        run: |
          echo "Initial PATH: $PATH"
          echo "GITHUB_PATH content:"
          cat $GITHUB_PATH || echo "GITHUB_PATH not found"

      # 3) Install build tool + build your wheel
      - name: Install build tooling
        run: |
          python -m pip install --upgrade pip
          python -m pip install build
      - name: Build wheel
        run: python -m build

      # 4) Install your wheel + AI backends via pip
      - name: Install solai wheel
        run: |
          wheel=$(ls dist/solai-*.whl)
          echo "Installing wheel: $wheel"
          python -m pip install --upgrade pip
          # Don't install [ai] extras since we're installing SWE-agent directly
          python -m pip install "${wheel}"
          python -m pip install pipx

      # 4a) Install Slither
      - name: Install Slither
        run: python -m pip install slither-analyzer

      # 4b) Install Foundry
      - name: Install Foundry
        run: |
          # 1) Create Foundry directories
          mkdir -p "$HOME/.foundry/bin"
          mkdir -p "$HOME/.config/.foundry/bin"
          # 2) Download foundryup
          curl -L https://raw.githubusercontent.com/foundry-rs/foundry/master/foundryup/foundryup -o "$HOME/.foundry/bin/foundryup"
          # 3) Make executable
          chmod +x "$HOME/.foundry/bin/foundryup"
          # 4) Add to temp PATH
          export PATH="$HOME/.foundry/bin:$PATH"
          # 5) Install full suite
          foundryup || echo "foundryup command failed with exit code $?"
          # 6) Verify
          ls -la "$HOME/.config/.foundry/bin/forge"
          # 7) Persist correct path
          echo "$HOME/.config/.foundry/bin" >> $GITHUB_PATH
          # 8) Verify again
          export PATH="$HOME/.config/.foundry/bin:$PATH"
          which forge
          forge --version

      # 4c) Install SWE-ReX (from source)
      - name: Install SWE-ReX
        run: |
          git clone https://github.com/SWE-agent/SWE-agent.git
          cd SWE-agent
          git checkout v1.0.1
          python -m pip install --upgrade pip
          # Install sweagent editable, forcing an older litellm version
          python -m pip install --editable ".[agent]" litellm==1.67.0
          cd ..
          which sweagent || echo "sweagent not found in PATH"

      # 5) Set up Docker
      - name: Set up QEMU emulation
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Debug: Post Docker PATH
      - name: Debug - Post Docker PATH
        run: |
          echo "PATH after Docker setup: $PATH"
          cat $GITHUB_PATH
          which forge || echo "forge not found in PATH"

      # 6) Build Phase 3 Required Docker Image
      - name: Build Phase 3 Docker Image
        id: docker_build # Add an ID to reference the output tag
        run: |
          ARCH=$(dpkg --print-architecture)
          BASE_TAG="foundry_sol:0.4.5" # Define base tag - UPDATED to 0.4.5
          ARCH_TAG="${BASE_TAG}-${ARCH}" # Define arch-specific tag
          echo "--- Building Phase 3 Docker image for ${ARCH} --- Base Tag: ${BASE_TAG} --- Arch Tag: ${ARCH_TAG} --- Using Dockerfile: src/solai/docker/foundry_sol.Dockerfile ---"
          # Build with ARCH tag, also tag with BASE tag
          docker build --platform "linux/${ARCH}" -t "${ARCH_TAG}" -t "${BASE_TAG}" -f src/solai/docker/foundry_sol.Dockerfile .
          echo "--- Docker image build finished ---"
          # Verify both tags exist
          docker images --format '{{.Repository}}:{{.Tag}}' | grep -Eq "^${ARCH_TAG}$" || { echo "‚ùå Failed to build or tag image ${ARCH_TAG} correctly"; exit 1; }
          docker images --format '{{.Repository}}:{{.Tag}}' | grep -Eq "^${BASE_TAG}$" || { echo "‚ùå Failed to build or tag image ${BASE_TAG} correctly"; exit 1; }
          echo "‚úì Images ${ARCH_TAG} and ${BASE_TAG} built successfully."
          # Output the ARCH-specific tag for subsequent steps (swe.yaml update, container ID search)
          echo "image_tag=${ARCH_TAG}" >> $GITHUB_OUTPUT

      # 7) Run Phase 3 Hello-World Test
      - name: Phase 3 - SWE-Agent Run
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          # Make sure the container ID search uses the dynamically built tag
          TARGET_IMAGE_TAG: ${{ steps.docker_build.outputs.image_tag }}
        run: |
          set -e
          echo "--- 1Ô∏è‚É£ Creating isolated failing demo repo ---"
          cd /tmp && rm -rf demo && mkdir demo && cd demo
          git init -q
          
          # Create contract
          cat > Greeter.sol << 'SOL'
          pragma solidity ^0.8.26;
          contract Greeter {
              string private greeting = "hello";
              function greet() external view returns (string memory) {
                  return greeting;
              }
          }
          SOL

          # Create test
          cat > Greeter.t.sol << 'SOLTEST'
          pragma solidity ^0.8.26;
          import "forge-std/Test.sol";
          import "./Greeter.sol";
          
          contract GreeterTest is Test {
              Greeter g;
              function setUp() public { g = new Greeter(); }
              /// @notice Wrong on purpose
              function testGreetingFails() public {
                  assertEq(g.greet(), "HELLO");
              }
          }
          SOLTEST

          forge test -q && { echo "‚ùå tests unexpectedly green"; exit 1; } || echo "‚úì baseline red"
          grep -q '"HELLO"' Greeter.t.sol || { echo "‚ùå 'HELLO' literal missing from test"; exit 1; }
          echo "‚úì Checkpoint 1 Passed"
          
          echo "--- 2Ô∏è‚É£ Authoring minimal swe.yaml ---"
          # Copy the template
          cp ${GITHUB_WORKSPACE}/.github/swe-agent-configs/phase3_hello_world.yaml swe.yaml
          # Modify the image tag IN PLACE using sed
          # Note: Need to match the indented 'image:' key under env.deployment
          sed -i "s#^\(\s*image:\s*\).*#\1${TARGET_IMAGE_TAG}#" swe.yaml
          echo "‚úì Updated swe.yaml config file to use image: ${TARGET_IMAGE_TAG}"
          cat swe.yaml # Optional: verify the change

          echo "--- 3Ô∏è‚É£ Running SWE-Agent inside SWE-ReX ---"
          TS=$(date +%Y%m%dT%H%M%S)
          LOGFILE="run_${TS}.log"
          
          # Ensure OpenAI key is set
          [[ -n "${OPENAI_API_KEY-}" ]] || { echo "‚ùå OPENAI_API_KEY is not set in env"; exit 1; }

          # Run swerex-remote, capture exit code, and attempt to get logs
          set +e # Allow the command to fail so we can capture logs
          ${SWE_REX_BIN:-sweagent} run --config swe.yaml --output_dir . 2>&1 | tee "$LOGFILE"
          exit_code=$?
          set -e # Re-enable exit on error

          echo "--- ü©∫ SWE-Agent Exit Code: $exit_code ---"
          
          # Attempt to get logs from the container (ALWAYS try after the run)
          echo "--- ü™µ Attempting to capture Docker container logs --- \t(Exit Code: $exit_code)"
          # Extract container name/ID from the log file
          # Example log line: "INFO     Starting container foundry_sol0.4.4-amd64-abcdef12-3456-7890-abcd-ef0123456789 with image ..."
          container_name=$(grep -oP 'INFO\\s+Starting container \\K[^\\s]+' "$LOGFILE" | head -n 1)

          if [ -n "$container_name" ]; then
            echo "Found container name/ID from log: $container_name"
            # Use the container name/ID to get logs. Use set +e in case container was already removed.
            set +e 
            docker logs "$container_name"
            logs_exit_code=$?
            set -e
            if [ $logs_exit_code -ne 0 ]; then
                echo "(Info: 'docker logs' failed for $container_name, container might have been removed already)"
            fi
          else
            echo "Could not find container name/ID in log file '$LOGFILE' for image ${TARGET_IMAGE_TAG}"
            # Fallback attempt using docker ps (might fail if container is removed)
            echo "--- ü™µ Fallback: Attempting to capture logs via docker ps --filter --- "
            container_id_ps=$(docker ps -a --filter "ancestor=${TARGET_IMAGE_TAG}" --format "{{.ID}}" | head -n 1)
             if [ -n "$container_id_ps" ]; then
                echo "Found container ID via ps: $container_id_ps for image ${TARGET_IMAGE_TAG}"
                docker logs "$container_id_ps"
             else
                echo "Could not find container ID via ps for image ${TARGET_IMAGE_TAG}"
             fi
          fi

          # Fail the step if the original command failed OR if the patch is missing
          if [ $exit_code -ne 0 ]; then
            echo "‚ùå SWE-Agent run failed with exit code $exit_code"
            exit $exit_code
          elif [ ! -s patch.tar ]; then
             echo "‚ùå patch.tar missing or empty after SWE-Agent run (Exit code: $exit_code)"
             # Don't exit immediately, run diagnostics first
             # exit 1 
          fi

          # Basic sanity check for patch file (only if sweagent succeeded AND patch exists)
          if [ -s patch.tar ]; then
            echo "‚úì Agent produced patch.tar"
          fi
          # REMOVED: Exit 1 from grep check to ensure diagnostic step runs
          docker ps -a --format '{{.Image}}' | grep -q "${TARGET_IMAGE_TAG}" || echo "‚ö†Ô∏è Warning: Container image ${TARGET_IMAGE_TAG} not found in docker ps -a output at this time."
          echo "‚úì Checkpoint 3 Passed (Using image ${TARGET_IMAGE_TAG})"

          echo "--- 4Ô∏è‚É£ Applying patch, enforcing guard-rails, re-testing ---"
          tar -xf patch.tar
          patch_files=( *.diff *.patch )
          if [ "${#patch_files[@]}" -eq 0 ]; then
             echo "‚ùå No patch files (*.diff or *.patch) found in patch.tar"; 
             echo "--- Contents of current directory ---"
             ls -la
             echo "--- Log file ($LOGFILE) ---"
             cat "$LOGFILE"
             exit 1; 
          fi
          
          for p in "${patch_files[@]}"; do
            echo "‚Üí validating $p"
            # Check file size first (robust against missing file)
            size=$(stat -c%s "$p" 2>/dev/null || echo 0)
            [ "$size" -lt 100000 ] || { echo "üí• $p >100 KB (size: $size)"; exit 1; }
            
            # Check LoC and apply
            git apply --stat "$p" | tee stat.txt
            loc_inserted=$(grep -oP '(\d+)\s+insertions?' stat.txt | awk '{s+=$1} END{print s}')
            loc_deleted=$(grep -oP '(\d+)\s+deletions?' stat.txt | awk '{s+=$1} END{print s}')
            loc_total=$((loc_inserted + loc_deleted)) # Consider total change size
            [ "$loc_total" -le 2000 ] || { echo "üí• patch changes $loc_total LOC (inserted: $loc_inserted, deleted: $loc_deleted)"; exit 1; }
            
            echo "Applying patch $p..."
            git apply "$p" || { echo "‚ùå Failed to apply patch $p"; exit 1; }
            echo "‚úì Patch $p applied successfully."
          done
          
          forge test -q && echo "‚úì tests green after patch" || { echo "‚ùå tests still failing after patch"; exit 1; }
          
          # Run Slither
          echo "Running Slither scan..."
          slither . --exclude-dependencies --disable-color | tee slither.txt
          if grep -Eiq 'Severity.*(Critical|High)' slither.txt; then
            echo "‚ùå high-severity issue found by Slither"; exit 1; 
          else
            echo "‚úì Slither OK - No critical/high severity issues found."
          fi
          echo "‚úì Checkpoint 4 Passed"

          echo "--- 5Ô∏è‚É£ Bundling evidence ---"
          mkdir -p .evidence
          mv patch.tar "$LOGFILE" stat.txt slither.txt .evidence/
          EVIDENCE_BUNDLE="phase3_evidence_${TS}.tgz"
          tar -czf "$EVIDENCE_BUNDLE" .evidence
          sha256sum "$EVIDENCE_BUNDLE" > "evidence_${TS}.hash"
          echo "‚úÖ Evidence bundle ready: $EVIDENCE_BUNDLE"
          # Output bundle name for artifact upload step
          echo "EVIDENCE_BUNDLE_NAME=$EVIDENCE_BUNDLE" >> $GITHUB_ENV
          
          echo "--- 6Ô∏è‚É£ Cleanup ---"
          # Minimal cleanup within the job - runner handles workspace cleanup
          cd .. # Move out of /tmp/demo
          rm -rf demo # Clean up demo dir
          # swerex cleanup is usually handled outside the main flow
          # ${SWE_REX_BIN:-swerex-remote} clean 

      # ADDED: Diagnostic step from recipe
      - name: Dump last container state
        if: always() # Always run this step - UPDATED from failure() || success()
        env:
          # Make sure we use the same tag as the failed step
          TARGET_IMAGE_TAG: ${{ steps.docker_build.outputs.image_tag }}
        run: |
          echo "--- üîé Diagnostic: Dumping last container state for image ${TARGET_IMAGE_TAG} ---"
          docker ps -a --no-trunc
          # UPDATED filter to use the dynamic tag directly
          cid=$(docker ps -a --filter "ancestor=${TARGET_IMAGE_TAG}" --format "{{.ID}}" | head -n1)
          if [ -n "$cid" ]; then
            echo "Found container ID: $cid"
            echo "=== docker logs $cid ==="
            # Use || true in case logs command fails (e.g., container removed quickly)
            docker logs "$cid" || true 
            echo "=== docker inspect (State) $cid ==="
            # Capture ExitCode and Error specifically
            docker inspect "$cid" --format 'ExitCode: {{.State.ExitCode}}, Error: {{.State.Error}}, Status: {{.State.Status}}' || true
          else
            echo "Could not find a container based on image ${TARGET_IMAGE_TAG}"
          fi

      # 8) Upload Phase 3 Evidence Bundle
      - name: Upload Phase 3 Evidence
        uses: actions/upload-artifact@v4
        with:
          name: phase3-evidence
          path: /tmp/${{ env.EVIDENCE_BUNDLE_NAME }}
          if-no-files-found: error # Fail the workflow if the bundle isn't found 