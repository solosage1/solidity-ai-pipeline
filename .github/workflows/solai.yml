name: solai-phase3-hello-world
on: [push]

defaults:
  run:
    shell: bash

env:
  DEBUG: "false"  # default debug flag for SWE-agent steps

jobs:
  lint-workflow:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check workflow files (Docker)
        uses: docker://rhysd/actionlint:latest

  lint-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python for linting/testing
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install and run linters + tests
        run: |
          python -m pip install --quiet actionlint pytest
          echo "--- Running actionlint ---"
          actionlint -color .github/workflows/solai.yml
          echo "--- Running pytest ---"
          pytest -q tests/

  phase3_hello_world:
    needs: [lint-workflow, lint-and-test]
    runs-on: ubuntu-latest
    timeout-minutes: 25
    env:
      # Define FOUNDRY_DIR at job level for use in cache and install steps
      FOUNDRY_DIR: /home/runner/.config/.foundry

    steps:
      # → Cache Python deps
      - uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-py3.12
          restore-keys: |
            ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-
            ${{ runner.os }}-pip-

      # 1) Grab your code
      - uses: actions/checkout@v4

      # 2) Ensure Python 3.12
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      # Export runner's interpreter path for root
      - name: Export PYBIN_DIR
        run: echo "PYBIN_DIR=$(python -c 'import sys, pathlib; print(pathlib.Path(sys.executable).parent)')" >> "$GITHUB_ENV"

      # Upgrade pip once at the beginning
      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      # 3) Install build tool + build your wheel
      - name: Install build tooling
        run: |
          python -m pip install build
      - name: Build wheel
        run: python -m build

      # 4) Install your wheel + AI backends via pip
      - name: Install solai wheel
        run: |
          wheel=$(ls dist/solai-*.whl)
          echo "Installing wheel: $wheel"
          # Don't install [ai] extras since we're installing SWE-agent directly
          python -m pip install --quiet "${wheel}"

      # Centralize PyYAML install for syntax checking later
      - name: Install PyYAML
        run: python -m pip install --quiet pyyaml

      # -------------------------------------------------------------
      # 4b) Determine latest Foundry version (does NOT need Foundry)
      # -------------------------------------------------------------
      - name: Lock Foundry version to v1.6.5
        id: foundry_version
        run: echo "version=v1.6.5" >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------
      # 4c) Restore Foundry from cache (if we already built it once)
      # -------------------------------------------------------------
      - name: Cache Foundry directory
        id: cache-foundry
        uses: actions/cache@v4
        with:
          path: ${{ env.FOUNDRY_DIR }}
          key: ${{ runner.os }}-foundry-${{ steps.foundry_version.outputs.version }}

      - name: Restore Foundry from cache
        if: steps.cache-foundry.outputs.cache-hit == 'true'
        run: |
          echo "${FOUNDRY_DIR}/bin" >> "$GITHUB_PATH"
          export PATH="${FOUNDRY_DIR}/bin:$PATH"
          forge --version

      # -------------------------------------------------------------
      # 4d) Install Foundry (ONLY if cache missed)
      # -------------------------------------------------------------
      - name: Install Foundry
        if: steps.cache-foundry.outputs.cache-hit != 'true'
        run: |
          # 1) Create Foundry directory
          mkdir -p "${FOUNDRY_DIR}/bin"
          # 2) Download foundryup directly into the standard dir
          curl -L https://raw.githubusercontent.com/foundry-rs/foundry/master/foundryup/foundryup \
               -o "${FOUNDRY_DIR}/bin/foundryup"
          # 3) Make executable
          chmod +x "${FOUNDRY_DIR}/bin/foundryup"
          # 4) Add to temp PATH
          export PATH="${FOUNDRY_DIR}/bin:$PATH"
          # 5) Install full suite
          foundryup || echo "foundryup command failed with exit code $?"
          # 6) Verify
          ls -la "${FOUNDRY_DIR}/bin/forge"
          # 7) Persist correct path
          echo "${FOUNDRY_DIR}/bin" >> "$GITHUB_PATH"
          # 8) Verify again
          export PATH="${FOUNDRY_DIR}/bin:$PATH"
          which forge
          forge --version

      # Debug: Post Docker PATH
      - name: Debug - Post Docker PATH
        if: ${{ env.DEBUG == 'true' }}
        run: |
          echo "PATH after Docker setup: $PATH"
          cat "$GITHUB_PATH"
          # skip redundant Foundry install if cache hit
          if [[ "${{ steps.cache-foundry.outputs.cache-hit }}" == 'true' ]]; then
            echo "Foundry cache hit – skipping binary path export"
          else
            which forge || echo "forge not found in PATH"
          fi

      # 4e) Install SWE-Agent & SWE-ReX
      - name: Install SWE-Agent & SWE-ReX
        run: |
          set -xeuo pipefail
          python -m pip install --quiet --no-cache-dir \
            "git+https://github.com/swe-agent/swe-agent@v1.0.1" \
            "swe-rex==1.2.1" \
            "openai>=1.76,<1.77" # Use range pinning

          echo "+++ Creating runtime stubs ..."
          python scripts/setup_stub_pkgs.py
          echo "+++ Verifying stubs ..."
          # Explicitly use the python from the setup-python step if needed
          # Example: "$PYBIN_DIR/python" scripts/verify_sweagent_setup.py
          python scripts/verify_sweagent_setup.py # Run verification script

          # Add verification of site-packages structure (refined log)
          echo "+++ Verifying site-packages structure (relevant directories)..."
          SITE_PKG_PATH=$(python -c 'import site; print(site.getsitepackages()[0])')
          echo "Relevant directories found in: $SITE_PKG_PATH"
          # Use find for targeted listing
          find "$SITE_PKG_PATH" -maxdepth 1 -type d \( -name config -o -name tools -o -name trajectories -o -name enterprise \) -print || echo "Warning: find command failed or no relevant directories found."
          echo "--- Site-packages structure verification complete."

          # Original smoke test (optional, keep for belt-and-suspenders)
          echo "+++ Running original import smoke-test..."
          python -c 'import sweagent; print("import ok:", sweagent.__version__)'
          echo "--- Original import smoke-test finished."

      # 7) Run Phase 3 Hello-World Test
      - name: Phase 3 - SWE-Agent Run  # single sudo, stripped user-site path
        id: swe_agent_run_step
        env:
          # Define secret in step env (sudo -E will forward)
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PYBIN_DIR: ${{ env.PYBIN_DIR }}
          # FOUNDRY_DIR is accessed from the job env within the BASH script
        # Use explicit python interpreter. API key forwarded by sudo -E.
        # Quote the shell command string to handle ${{...}} safely for linters.
        shell: "sudo -E \"$PYBIN_DIR/python\" - <<'BASH'"
        run: |
          set -euo pipefail
          # This script now runs via the specific python interpreter.

          # PATH is handled by GITHUB_PATH setup earlier, no need to export here
          # if [ -z "$FOUNDRY_DIR" ]; then ... ; fi # Check removed, assume GITHUB_PATH works
          # export PATH="$FOUNDRY_DIR/bin:$PATH" # Removed

          # Verify sweagent CLI is callable *through the python interpreter*
          if ! python -m sweagent --version > /dev/null 2>&1; then
              echo "❌ sweagent command not runnable via $PYBIN_DIR/python -m"
              exit 1
          fi
          echo "✓ sweagent command runnable via python -m"

          # 1️⃣ Create isolated failing demo repo
          cd /tmp && rm -rf demo && mkdir demo && cd demo
          git init -q

          cat > Greeter.sol << 'SOL'
          pragma solidity ^0.8.26;
          contract Greeter {
              string private greeting = "hello";
              function greet() external view returns (string memory) {
                  return greeting;
              }
          }
          SOL

          # align heredoc indentation
          cat > Greeter.t.sol << 'SOLTEST'
          pragma solidity ^0.8.26;
          import "forge-std/Test.sol";
          import "./Greeter.sol";

          contract GreeterTest is Test {
              Greeter g;
              function setUp() public { g = new Greeter(); }
              /// @notice Wrong on purpose
              function testGreetingFails() public {
                  assertEq(g.greet(), "HELLO");
              }
          }
          SOLTEST

          # Expect failure – baseline should be red.
          if forge test -q 2>/dev/null; then
            printf '%s\n' '❌ tests unexpectedly green'
            exit 1
          else
            printf '%s\n' '✓ baseline red (silenced warning)'
          fi

          if ! grep -q '"HELLO"' Greeter.t.sol; then
            printf '%s\n' '❌ HELLO literal missing'
            exit 1
          fi
          printf '%s\n' '✓ Checkpoint 1 Passed'

          printf '%s\n' '--- 2️⃣ Creating minimal valid swe.yaml ---'
          cat > swe.yaml << 'YAML'
          problem_statement:
            text: "Fix failing tests"

          agent:
            model:
              name: gpt-4o-mini
            # Add spending cap
            usd_cap: 0.20
            action_sampler: {}

          env:
            repo:
              path: .
            deployment:
              type: local

          actions:
            open_pr: false
            apply_patch_locally: true
          YAML
          printf '%s\n' "✓ Created swe.yaml with local deployment"

          printf '%s\n' '--- 2b️⃣ Validating swe.yaml syntax ---'
          # First check basic YAML syntax
          # NOTE: We must use the explicit python interpreter here too!
          "$PYBIN_DIR/python" - << 'PY'
          import yaml, sys
          try:
              yaml.safe_load(open("swe.yaml"))
              print("✓ swe.yaml valid YAML syntax")
          except Exception as e:
              print("❌ swe.yaml syntax error detected. Please review the file format and indentation.")
              print(e)
              sys.exit(1)
          PY

          # Optional YAML debug output
          if [[ "$DEBUG" == "true" ]]; then
            echo "--- swe.yaml content preview ---"
            cat swe.yaml
            echo "---------------------------------"
          fi

          # Do a schema-only check if supported by sweagent CLI
          if sweagent --help | grep -q -- "--dry-run"; then
            printf '%s\n' "--- 2c️⃣ Performing schema validation with --dry-run ---"
            if ! sweagent run --config swe.yaml --dry-run; then
              printf '%s\n' "❌ Schema validation failed - config structure doesn't match SWE-agent v1.0.1 requirements"
              exit 1
            fi
            printf '%s\n' "✓ Schema validation passed"
          else
            printf '%s\n' "--- 2c️⃣ Skipping schema validation (--dry-run not supported) ---"
          fi

          printf '%s\n' '--- 3️⃣ Running SWE-Agent inside SWE-ReX ---'
          TS=$(date +%Y%m%dT%H%M%S)
          LOGFILE="run_${TS}.log"

          # Define the main command - now run via python -m
          SWE_AGENT_CMD="\"$PYBIN_DIR/python\" -m sweagent run --config swe.yaml --output_dir ."
          if [[ "${DEBUG}" == "true" ]]; then
            SWE_AGENT_CMD="${SWE_AGENT_CMD} --verbose"
          fi

          set +e
          eval "$SWE_AGENT_CMD" 2>&1 | tee "$LOGFILE"
          ret=$?
          set -e

          printf '%s\n' "--- 🩺 Exit Code: $ret"
          if [ "$ret" -ne 0 ] || [ ! -s patch.tar ]; then
            # Always print the full sweagent log on failure
            printf '%s\n' "--- 📝 Full sweagent log contents ($LOGFILE) ---"
            cat "$LOGFILE"
            printf '%s\n' '❌ SWE-Agent run failed or patch missing'
            exit 1
          fi

          printf '%s\n' '✓ Agent produced patch.tar'
          printf '%s\n' '--- 4️⃣ Applying patch... ---'
          tar -xf patch.tar
          mapfile -d $'\0' patch_files < <(find . -maxdepth 1 -name '*.[pd][ia][ft]' -print0)

          if [ "${#patch_files[@]}" -eq 0 ]; then
            printf '%s\n' '❌ No patch files'
            exit 1
          fi

          for p in "${patch_files[@]}"; do
            [ -z "$p" ] && continue
            printf '%s\n' "→ validating $p"
            size=$(stat -c%s "$p")
            [ "$size" -lt 100000 ] || { printf '%s\n' "💥 $p too large"; exit 1; }

            git apply --stat "$p" > stat.txt
            loc_ins=$(grep -oP '(\d+)\s+insertions?' stat.txt | awk '{s+=$1} END{print s}')
            loc_del=$(grep -oP '(\d+)\s+deletions?' stat.txt | awk '{s+=$1} END{print s}')
            total=$((loc_ins+loc_del))
            [ "$total" -le 2000 ] || { printf '%s\n' "💥 patch $p changes $total LOC"; exit 1; }

            printf '%s\n' "Applying $p"
            git apply "$p" || { printf '%s\n' "❌ apply failed $p"; exit 1; }
          done

          # Verify tests pass after patch
          if forge test -q; then
            printf '%s\n' '✓ tests green after patch'
          else
            printf '%s\n' '❌ tests still failing'
            git diff
            exit 1
          fi

          # Always run Slither after successful patch application (inside Docker)
          printf '%s\n' '--- 4b Running Slither inside Docker ---'
          # Define the docker image name - ensure it matches build/pull steps if applicable
          # Assuming image is available locally from previous steps or pulled
          # If image name needs versioning, adjust here.
          DOCKER_IMG="foundry_sol:latest" # Or use a more specific tag like 0.4.4 if available
          if docker image inspect "$DOCKER_IMG" &> /dev/null; then
              echo "Running slither using image: $DOCKER_IMG"
              # Run Slither inside the container, mounting current dir
              # Use docker run --rm to clean up container afterwards
              docker run --rm -v "$PWD":/src "$DOCKER_IMG" slither /src --exclude-dependencies --disable-color > slither.txt || \
                  echo "Slither returned non-zero exit code, proceeding..."
              echo "Slither analysis complete."
          else
               echo "Warning: Docker image $DOCKER_IMG not found. Skipping Slither analysis." >&2
               # Create empty file so bundling step doesn't fail if it expects it
               touch slither.txt
          fi

          printf '%s\n' '--- 5️⃣ Bundling evidence ---'
          mkdir -p .evidence
          # Handle potential missing stat.txt gracefully
          [ -f stat.txt ] && mv stat.txt .evidence/
          # Always move slither.txt (even if empty or from failed run)
          [ -f slither.txt ] && mv slither.txt .evidence/
          mv patch.tar "$LOGFILE" .evidence/
          TB="phase3_evidence_${TS}.tgz"
          tar -czf "$TB" .evidence
          # Move bundle to /tmp for upload
          mv "$TB" /tmp/
          echo "bundle_name=$TB" >> "$GITHUB_OUTPUT"
          printf '%s\n' "✅ Evidence: $TB"
        # The BASH heredoc is terminated by the shell command's syntax,
        # not an explicit marker in the YAML content here.

      # 8) Upload Phase 3 Evidence Bundle
      - name: Upload Phase 3 Evidence
        uses: actions/upload-artifact@v4
        with:
          name: phase3-evidence
          path: /tmp/${{ steps.swe_agent_run_step.outputs.bundle_name }}
          if-no-files-found: error 