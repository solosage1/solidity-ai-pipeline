name: solai-phase3-hello-world
on: [push]

jobs:
  lint-workflow:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check workflow files
        uses: docker://rhysd/actionlint:latest
        with:
          ignore: 'SC2046'  # Allow word splitting in command substitution

  phase3_hello_world:
    needs: lint-workflow
    runs-on: ubuntu-latest
    env:
      # Define FOUNDRY_DIR at job level for use in cache and install steps
      FOUNDRY_DIR: /home/runner/.config/.foundry

    steps:
      # 1) Grab your code
      - uses: actions/checkout@v4

      # 2) Ensure Python 3.12
      - name: Set up Python 3.12
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      # Upgrade pip once at the beginning
      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      # Debug: Initial PATH state
      - name: Debug - Initial PATH
        run: |
          echo "Initial PATH: $PATH"
          echo "GITHUB_PATH content:"
          cat $GITHUB_PATH || echo "GITHUB_PATH not found"

      # 3) Install build tool + build your wheel
      - name: Install build tooling
        run: |
          python -m pip install build
      - name: Build wheel
        run: python -m build

      # 4) Install your wheel + AI backends via pip
      - name: Install solai wheel
        run: |
          wheel=$(ls dist/solai-*.whl)
          echo "Installing wheel: $wheel"
          # Don't install [ai] extras since we're installing SWE-agent directly
          python -m pip install --quiet "${wheel}"

      # 4a) Install Slither
      - name: Install Slither
        run: python -m pip install --quiet "slither-analyzer>=0.11.3"

      # 4b) Install Foundry
      - name: Cache Foundry directory
        id: cache-foundry
        uses: actions/cache@v4
        with:
          path: ${{ env.FOUNDRY_DIR }} # Now correctly references job-level env var
          key: ${{ runner.os }}-foundry-v0.4.6 # Key includes OS and base tag version

      - name: Install Foundry
        # Only run if cache wasn't restored
        if: steps.cache-foundry.outputs.cache-hit != 'true'
        run: |
          # 1) Create Foundry directories
          mkdir -p "$HOME/.foundry/bin" # Still needed for foundryup download
          mkdir -p "${FOUNDRY_DIR}/bin"
          # 2) Download foundryup
          curl -L https://raw.githubusercontent.com/foundry-rs/foundry/master/foundryup/foundryup -o "$HOME/.foundry/bin/foundryup"
          # 3) Make executable
          chmod +x "$HOME/.foundry/bin/foundryup"
          # 4) Add to temp PATH
          export PATH="$HOME/.foundry/bin:$PATH"
          # 5) Install full suite
          foundryup || echo "foundryup command failed with exit code $?"
          # 6) Verify
          ls -la "${FOUNDRY_DIR}/bin/forge"
          # 7) Persist correct path
          echo "${FOUNDRY_DIR}/bin" >> $GITHUB_PATH
          # 8) Verify again
          export PATH="${FOUNDRY_DIR}/bin:$PATH"
          which forge
          forge --version

      # 4c) Install SWE-Agent & SWE-ReX (from GitHub releases)
      - name: Install SWE-Agent & SWE-ReX
        run: |
          python -m pip install --quiet --no-cache-dir \
          "git+https://github.com/princeton-nlp/SWE-agent.git@v0.4.0" \
          "swe-rex==1.2.1" \
          "openai>=1.75.0,<2"
          # Verify installation
          sweagent --version
          which sweagent || { echo "sweagent not found in PATH after install"; exit 1; }

      # 5) Set up Docker
      - name: Set up QEMU emulation
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Debug: Post Docker PATH
      - name: Debug - Post Docker PATH
        run: |
          echo "PATH after Docker setup: $PATH"
          cat $GITHUB_PATH
          # skip redundant Foundry install if cache hit
          if [[ "${{ steps.cache-foundry.outputs.cache-hit }}" == 'true' ]]; then
            echo "Foundry cache hit ‚Äì skipping binary path export"
          else
            which forge || echo "forge not found in PATH"
          fi

      # 6) Build Phase 3 Required Docker Image
      - name: Build Phase 3 Docker Image
        id: docker_build # Add an ID to reference the output tag
        run: |
          ARCH=$(dpkg --print-architecture)
          BASE_TAG="foundry_sol:0.4.6" # UPDATED base tag to 0.4.6
          ARCH_TAG="${BASE_TAG}-${ARCH}"       # Define arch-specific tag
          echo "--- Building Phase 3 Docker image for ${ARCH} --- Base Tag: ${BASE_TAG} --- Arch Tag: ${ARCH_TAG} --- Using Dockerfile: src/solai/docker/foundry_sol.Dockerfile ---"
          # Build with ARCH tag, also tag with BASE tag
          docker build --platform "linux/${ARCH}" -t "${ARCH_TAG}" -t "${BASE_TAG}" --progress=plain \
                      -f src/solai/docker/foundry_sol.Dockerfile .
          echo "--- Docker image build finished ---"
          # Verify both tags exist
          docker images --format '{{.Repository}}:{{.Tag}}' | grep -Eq "^${ARCH_TAG}$" || { echo "‚ùå Failed to build or tag image ${ARCH_TAG} correctly"; exit 1; }
          # Only verify the arch-specific tag; we stopped writing the generic one
          echo "‚úì Image ${ARCH_TAG} built successfully."
          # Output the ARCH-specific tag for subsequent steps (swe.yaml update, container ID search)
          echo "image_tag=${ARCH_TAG}" >> $GITHUB_OUTPUT

      # 7) Run Phase 3 Hello-World Test
      - name: Phase 3 - SWE-Agent Run
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          # Make sure the container ID search uses the dynamically built tag
          TARGET_IMAGE_TAG: ${{ steps.docker_build.outputs.image_tag }}
        run: |
          set -e
          echo "--- 1Ô∏è‚É£ Creating isolated failing demo repo ---"
          cd /tmp && rm -rf demo && mkdir demo && cd demo
          git init -q
          
          # Create contract
          cat > Greeter.sol << 'SOL'
          pragma solidity ^0.8.26;
          contract Greeter {
              string private greeting = "hello";
              function greet() external view returns (string memory) {
                  return greeting;
              }
          }
          SOL

          # Create test
          cat > Greeter.t.sol << 'SOLTEST'
          pragma solidity ^0.8.26;
          import "forge-std/Test.sol";
          import "./Greeter.sol";
          
          contract GreeterTest is Test {
              Greeter g;
              function setUp() public { g = new Greeter(); }
              /// @notice Wrong on purpose
              function testGreetingFails() public {
                  assertEq(g.greet(), "HELLO");
              }
          }
          SOLTEST

          forge test -q && { echo "‚ùå tests unexpectedly green"; exit 1; } || echo "‚úì baseline red"
          forge test --match-path Greeter.t.sol -q && { echo "‚ùå tests unexpectedly green"; exit 1; } || echo "‚úì baseline red"
          grep -q '"HELLO"' Greeter.t.sol || { echo "‚ùå 'HELLO' literal missing from test"; exit 1; }
          echo "‚úì Checkpoint 1 Passed"
          
          echo "--- 2Ô∏è‚É£ Authoring minimal swe.yaml ---"
          # Copy the template
          cp ${GITHUB_WORKSPACE}/.github/swe-agent-configs/phase3_hello_world.yaml swe.yaml
          # Modify the image tag IN PLACE using sed
          sed -i "s|DYNAMIC_IMAGE_TAG_PLACEHOLDER|${TARGET_IMAGE_TAG}|" swe.yaml
          echo "‚úì Updated swe.yaml config file to use image: ${TARGET_IMAGE_TAG} (keep_container is static)"
          cat swe.yaml # Optional: verify the change

          echo "--- 2bÔ∏è‚É£ Linting swe.yaml configuration ---"
          sweagent lint-config swe.yaml || { echo "‚ùå swe.yaml configuration failed validation"; exit 1; }
          echo "‚úì swe.yaml configuration is valid."

          echo "--- 3Ô∏è‚É£ Running SWE-Agent inside SWE-ReX ---"
          TS=$(date +%Y%m%dT%H%M%S)
          LOGFILE="run_${TS}.log"
          
          # Ensure OpenAI key is set
          : "${OPENAI_API_KEY:?OPENAI_API_KEY not set}"   # safer secret check

          # Run swerex-remote, capture exit code, and attempt to get logs
          set +e # Allow the command to fail so we can capture logs
          # Using sweagent directly (should be in PATH)
          sweagent run --config swe.yaml --output_dir . 2>&1 | tee "$LOGFILE"
          exit_code=$?
          set -e # Re-enable exit on error

          echo "--- ü©∫ SWE-Agent Exit Code: $exit_code ---"
          
          # Attempt to get logs from the container (ALWAYS try after the run)
          echo "--- ü™µ Attempting to capture Docker container logs --- \t(Exit Code: $exit_code)"
          # Extract container name/ID from the log file
          # Example log line: "INFO     Starting container foundry_sol0.4.4-amd64-abcdef12-3456-7890-abcd-ef0123456789 with image ..."
          container_name=$(grep -oP 'INFO\\s+Starting container \\K[^\\s]+' "$LOGFILE" | head -n 1)

          if [ -n "$container_name" ]; then
            echo "Found container name/ID from log: $container_name"
            # Use the container name/ID to get logs. Use set +e in case container was already removed.
            set +e 
            docker logs "$container_name"
            logs_exit_code=$?
            set -e
            if [ $logs_exit_code -ne 0 ]; then
                echo "(Info: 'docker logs' failed for $container_name, container might have been removed already)"
            fi
          else
            echo "Could not find container name/ID in log file '$LOGFILE' for image ${TARGET_IMAGE_TAG}"
            # Fallback attempt using docker ps (might fail if container is removed)
            echo "--- ü™µ Fallback: Attempting to capture logs via docker ps --filter --- "
            container_id_ps=$(docker ps -a --filter "ancestor=${TARGET_IMAGE_TAG}" --format "{{.ID}}" | head -n 1)
             if [ -n "$container_id_ps" ]; then
                echo "Found container ID via ps: $container_id_ps for image ${TARGET_IMAGE_TAG}"
                docker logs "$container_id_ps"
             else
                echo "Could not find container ID via ps for image ${TARGET_IMAGE_TAG}"
             fi
          fi

          # Fail the step if the original command failed OR if the patch is missing
          if [ $exit_code -ne 0 ]; then
            echo "‚ùå SWE-Agent run failed with exit code $exit_code"
            exit $exit_code
          elif [ ! -s patch.tar ]; then
             echo "‚ùå patch.tar missing or empty after SWE-Agent run (Exit code: $exit_code)"
             exit 1 # Fail fast if patch is missing
          fi

          # Basic sanity check for patch file (only if sweagent succeeded AND patch exists)
          if [ -s patch.tar ]; then
            echo "‚úì Agent produced patch.tar"
          fi
          # REMOVED: Exit 1 from grep check to ensure diagnostic step runs
          docker ps -a --format '{{.Image}}' | grep -q "${TARGET_IMAGE_TAG}" || echo "‚ö†Ô∏è Warning: Container image ${TARGET_IMAGE_TAG} not found in docker ps -a output at this time."
          echo "‚úì Checkpoint 3 Passed (Using image ${TARGET_IMAGE_TAG})"

          echo "--- 4Ô∏è‚É£ Applying patch, enforcing guard-rails, re-testing ---"
          tar -xf patch.tar
          patch_files=( *.diff *.patch )
          if [ "${#patch_files[@]}" -eq 0 ]; then
             echo "‚ùå No patch files (*.diff or *.patch) found in patch.tar"; 
             echo "--- Contents of current directory ---"
             ls -la
             echo "--- Log file ($LOGFILE) ---"
             cat "$LOGFILE"
             exit 1; 
          fi
          
          for p in "${patch_files[@]}"; do
            echo "‚Üí validating $p"
            # Check file size first (robust against missing file)
            size=$(stat -c%s "$p" 2>/dev/null || echo 0)
            [ "$size" -lt 100000 ] || { echo "üí• $p >100 KB (size: $size)"; exit 1; }
            
            # Check LoC and apply
            git apply --stat "$p" | tee stat.txt
            loc_inserted=$(grep -oP '(\d+)\s+insertions?' stat.txt | awk '{s+=$1} END{print s}')
            loc_deleted=$(grep -oP '(\d+)\s+deletions?' stat.txt | awk '{s+=$1} END{print s}')
            loc_total=$((loc_inserted + loc_deleted)) # Consider total change size
            [ "$loc_total" -le 2000 ] || { echo "üí• patch changes $loc_total LOC (inserted: $loc_inserted, deleted: $loc_deleted)"; exit 1; }
            
            echo "Applying patch $p..."
            git apply "$p" || { echo "‚ùå Failed to apply patch $p"; exit 1; }
            echo "‚úì Patch $p applied successfully."
          done
          
          forge test -q && echo "‚úì tests green after patch" || { echo "‚ùå tests still failing after patch"; exit 1; }
          
          # Run Slither
          echo "Running Slither scan..."
          slither . --exclude-dependencies --disable-color | tee slither.txt
          if grep -Eiq 'Severity.*(Critical|High)' slither.txt; then
            echo "‚ùå high-severity issue found by Slither"; exit 1; 
          else
            echo "‚úì Slither OK - No critical/high severity issues found."
          fi
          echo "‚úì Checkpoint 4 Passed"

          echo "--- 5Ô∏è‚É£ Bundling evidence ---"
          mkdir -p .evidence
          mv patch.tar "$LOGFILE" stat.txt slither.txt .evidence/
          EVIDENCE_BUNDLE="phase3_evidence_${TS}.tgz"
          tar -czf "$EVIDENCE_BUNDLE" .evidence
          sha256sum "$EVIDENCE_BUNDLE" > "evidence_${TS}.hash"
          echo "‚úÖ Evidence bundle ready: $EVIDENCE_BUNDLE"
          # Move bundle to /tmp to prevent deletion with demo dir
          mv "$EVIDENCE_BUNDLE" /tmp/
          echo "‚úì Moved $EVIDENCE_BUNDLE to /tmp/"
          # Move hash file too
          mv "evidence_${TS}.hash" /tmp/
          echo "‚úì Moved evidence_${TS}.hash to /tmp/"
          # Output bundle name for artifact upload step
          echo "EVIDENCE_BUNDLE_NAME=$EVIDENCE_BUNDLE" >> $GITHUB_ENV
          # Output hash file name for artifact upload step
          echo "EVIDENCE_HASH_NAME=evidence_${TS}.hash" >> $GITHUB_ENV
          
          echo "--- 6Ô∏è‚É£ Cleanup ---"
          # Minimal cleanup within the job - runner handles workspace cleanup
          cd .. # Move out of /tmp/demo
          rm -rf demo # Clean up demo dir
          # swerex cleanup is usually handled outside the main flow
          # ${SWE_REX_BIN:-swerex-remote} clean 

      # ADDED: Diagnostic step from recipe
      - name: Dump last container state
        if: always() # Always run this step
        env:
          # Make sure we use the same tag as the build step
          TARGET_IMAGE_TAG: ${{ steps.docker_build.outputs.image_tag }}
        run: |
          # REPLACED SCRIPT with more robust version
          echo "‚è¨ docker ps -a"
          docker ps -a --no-trunc
          
          # Pick the most recent container started from our image
          # Using TARGET_IMAGE_TAG which is correctly set in env above
          CID=$(docker ps -a --filter "ancestor=${TARGET_IMAGE_TAG}" --format '{{.ID}}' | head -n1)
          
          if [ -z "$CID" ]; then
            echo "‚ùå Could not find any stopped container for image ${TARGET_IMAGE_TAG}"
            # Exit 0 here to allow workflow to proceed and potentially fail later 
            # based on missing artifacts, ensuring we always see this message if needed.
            exit 0
          fi
          
          echo "Found container ID: $CID"
          echo "‚è¨ docker inspect $CID | jq '.[0].State'"
          # Ensure jq is available (should be on standard runners)
          # If jq fails, the raw inspect output might still be partially useful
          docker inspect "$CID" | jq '.[0].State' || echo "jq command failed, raw inspect output might be above"
          
          echo "‚è¨ docker logs $CID (last 200 lines)"
          docker logs --tail 200 "$CID" || true

      # 8) Upload Phase 3 Evidence Bundle
      - name: Upload Phase 3 Evidence
        uses: actions/upload-artifact@v4
        with:
          name: phase3-evidence
          path: |
            /tmp/${{ env.EVIDENCE_BUNDLE_NAME }}
            /tmp/${{ env.EVIDENCE_HASH_NAME }}
          if-no-files-found: error # Fail the workflow if the bundle isn't found 